/*
This is supposed to create the database, we will see...
*/

/* delete complete db */
DROP SCHEMA PUBLIC CASCADE;

/* -------------------- Setup Tables -------------------- */

/* Holds all type information */
CREATE TABLE type (
    /* use the standard syntax and explicity declare a primary key identity column */
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    parentId INTEGER, 
    typeName VARCHAR(1024) UNIQUE NOT NULL
);

/* All methods which are somewhere called on some type */
CREATE TABLE method (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    typeId INTEGER FOREIGN KEY REFERENCES type(id),
    methodName VARCHAR(1024) NOT NULL
);

CREATE TABLE project (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(1024) NOT NULL,
    analysisTime INTEGER
);

/* Information for type usages which is not calculated and excluding the call list */
CREATE TABLE typeusage (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    typeId INTEGER FOREIGN KEY REFERENCES type(id),
    class VARCHAR(1024) NOT NULL,
    lineNr INTEGER,
    context VARCHAR(1024) NOT NULL,
    projectId INTEGER FOREIGN KEY REFERENCES project(id)
);
CREATE INDEX in_typeusageT ON typeusage (typeId);
CREATE INDEX in_typeusageC ON typeusage (context);
CREATE INDEX in_typeusage ON typeusage (typeId, context);
CREATE INDEX in_typeusageP ON typeusage (projectId);

/* links method and type usages to a list of method calls */
CREATE TABLE callList (
    typeusageId INTEGER FOREIGN KEY REFERENCES typeusage(id),
    methodId INTEGER FOREIGN KEY REFERENCES method(id),
    position INTEGER
);
CREATE INDEX in_callList ON callList (typeusageId);
CREATE INDEX in_callList1 ON callList (methodId);
CREATE INDEX in_callList2 ON callList (typeusageId, methodId);

-- Stuff only related to displaying things
DROP SCHEMA IF EXISTS display CASCADE;
CREATE SCHEMA display;

/* A list of calls for each type usage */
CREATE VIEW display.typeusageCalls (id, methodCalls) AS
  SELECT tu.id, GROUP_CONCAT(method.methodName SEPARATOR ', ')
  FROM typeusage tu
    JOIN callList cl ON tu.id = cl.typeusageId
    JOIN method ON cl.methodId = method.id
  GROUP BY tu.id /* ORDER BY cl.position */
;

/* Show complete typeusages as they would be printed -  location, lineNr, methodContext, type, methodCalls, (_extends) */
CREATE VIEW display.typeusageComplete (id, class, lineNr, context, typeName, methodCalls, projectName) AS
  SELECT tu.id, tu.class, tu.lineNr, tu.context, type.typeName, tuc.methodCalls, p.name
  FROM typeusage tu, type, display.typeusageCalls tuc, project p
  WHERE tu.typeId = type.id AND tu.id = tuc.id AND tu.projectId = p.id
;

-- build strangenessWrongMethodcall and StrangenessMethodTooMuch in the same way?
-- wrong method call == ae -> difference 1 on both sides instead of 0
-- method too much difference the other way around?

-- strangeness score related to calling the WRONG method -> diference has to be symmetrical 1 AND the same method is called (damn, this means lots of nested clauses...)
/*
seems to be pretty complicated right now, need to consider not only the NUMBER but also which call is missing -> build lots of tables in between.
Should be no problem, but not now

CREATE VIEW strangenessWrongMethodCall AS
WITH extendedCallListDiff AS
SELECT ta.id as leftId, tb.id AS rightId, 
    (SELECT  COUNT(*) FROM (SELECT clc.methodId FROM callList clc WHERE tb.id = clc.typeusageId
        EXCEPT SELECT cld.methodId FROM callList cld WHERE ta.id = cld.typeusageId)) AS difference
    FROM typeusage ta JOIN typeusage tb ON ta.typeId = tb.typeId AND ta.context = tb.context

*/



/* Mapping from supertypes to all their children */
/*
CREATE VIEW children AS
WITH RECURSIVE rec(parentId,childId) AS (
    SELECT NULL, type.typeId FROM type
    WHERE type.parentId IS NULL -- this condition defines the ultimate ancestors in your chain, change it as appropriate
    UNION ALL
        SELECT rec.typeId, t.typeId FROM type t, rec
        ON t.parentID = rec.typeId
)
SELECT  * FROM rec
;
*/

/*

todos:
understand views / those things I remember to be persistent
look into indices!

--- 
unfinished business:

VIEWS: (are those the ones which are kept persistently and only updated?)

CHILDREN (Parent type id, child type id) -> contains reverse, all children of one parent
EQUAL (tu id, tu id)
ALMOST_EQUAL (tu id, tu id)

Strangeness (tu id, strangeness score)

*/
