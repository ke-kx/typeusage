/*
This is supposed to create the database, we will see...
*/

/* delete complete db */
DROP SCHEMA PUBLIC CASCADE;

/* -------------------- Setup Tables -------------------- */

/* Holds all type information */
CREATE TABLE type (
    /* use the standard syntax and explicity declare a primary key identity column */
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    parentId INTEGER, 
    typeName VARCHAR(1024) UNIQUE NOT NULL
);

/* All methods which are somewhere called on some type */
CREATE TABLE method (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    typeId INTEGER FOREIGN KEY REFERENCES type(id),
    methodName VARCHAR(1024) NOT NULL
);

/* Information for type usages which is not calculated and excluding the call list */
CREATE TABLE typeusage (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    typeId INTEGER FOREIGN KEY REFERENCES type(id),
    class VARCHAR(1024) NOT NULL,
    lineNr INTEGER,
    context VARCHAR(1024) NOT NULL
);

/* links method and type usages to a list of method calls */
CREATE TABLE callList (
    typeusageId INTEGER FOREIGN KEY REFERENCES typeusage(id),
    methodId INTEGER FOREIGN KEY REFERENCES method(id),
    position INTEGER
);
CREATE INDEX in_callList ON callList (typeusageId);


-- build strangenessWrongMethodcall and StrangenessMethodTooMuch in the same way?
-- wrong method call == ae -> difference 1 on both sides instead of 0
-- method too much difference the other way around?

-- strangeness score related to calling the WRONG method -> diference has to be symmetrical 1 AND the same method is called (damn, this means lots of nested clauses...)
/*
seems to be pretty complicated right now, need to consider not only the NUMBER but also which call is missing -> build lots of tables in between.
Should be no problem, but not now

CREATE VIEW strangenessWrongMethodCall AS
WITH extendedCallListDiff AS
SELECT ta.id as leftId, tb.id AS rightId, 
    (SELECT  COUNT(*) FROM (SELECT clc.methodId FROM callList clc WHERE tb.id = clc.typeusageId
        EXCEPT SELECT cld.methodId FROM callList cld WHERE ta.id = cld.typeusageId)) AS difference
    FROM typeusage ta JOIN typeusage tb ON ta.typeId = tb.typeId AND ta.context = tb.context

*/



/* Mapping from supertypes to all their children */
/*
CREATE VIEW children AS
WITH RECURSIVE rec(parentId,childId) AS (
    SELECT NULL, type.typeId FROM type
    WHERE type.parentId IS NULL -- this condition defines the ultimate ancestors in your chain, change it as appropriate
    UNION ALL
        SELECT rec.typeId, t.typeId FROM type t, rec
        ON t.parentID = rec.typeId
)
SELECT  * FROM rec
;
*/

/*

todos:
understand views / those things I remember to be persistent
look into indices!

--- 
unfinished business:

VIEWS: (are those the ones which are kept persistently and only updated?)

CHILDREN (Parent type id, child type id) -> contains reverse, all children of one parent
EQUAL (tu id, tu id)
ALMOST_EQUAL (tu id, tu id)

Strangeness (tu id, strangeness score)

*/